<div class = "ampleforthDocumentClass" name = "WitherProgramming" classBody = "() (
) : (
)
" </div><div class = "ampleforthDocumentBody"><body><div class="self_ampleforth" contenteditable="true" style="border: 2px solid blue; resize: horizontal; overflow: auto; overflow-wrap: break-word; width: 40em;" onkeyup="updateRawHTML()"> <h1>W(h)ither Programming?</h1>
<div><br></div>There is much debate about how far we are from true AI, how long until we get there, is it sentient or will it be and when, how dangerous is it etc. Regardless, the time when machines can program themselves is approaching, and faster than we ever thought. Whether it is two years or five or ten, it is not too early to start thinking about the future of programming, programs and programming languages.<div><br></div><div><div>
<div><i><b>Tangent 1: </b>While the latest tools are in many ways spectacular, it's worth noting ways where they still differ from natural intelligence.</i></div><div><i><br></i></div><div></div><div><ol><li><i>&nbsp;Training requirements. A human does not need to read the entire internet to learn to speak. A human child does get years worth of stereoscopic video/audio coupled with haptic, olfactory and taste input, which should not be underestimated.&nbsp;</i></li><li><i>Embodiment/Multimodality. As noted above, the brain is trained on multimodal data, which allows it to correlate language and various physical phenomena in an integrated way, and therefore build up common-sense/semantic understanding of the real world.</i></li><li><i>Separation of training from inference. This separation doesn't exist in humans. We can transfer new information into long term memory, changing the network weights dynamically.</i></li><li><i>Memory vs Computation. These are distinct in digital computers, but integrated in the brain.</i></li><li><i>Energy requirements. The human brain uses only a few watts of energy. AI demands large amounts of compute even during inference (let alone training) and these use up orders of magnitude more power.</i></li><li><i>Goals. AI does not have its own goals shaped by evolution. There is however the claim that the goals of survival, power and resource seeking are universal subgoals, known as&nbsp;instrumental&nbsp;goals, that AI will discover as subgoals for any purpose.</i></li></ol><i><br></i></div>
<i><b>Tangent 2:</b>
The actual rate of adoption of generative AI is likely to be limited by various externalities. Social acceptance, and the regulation it drives, will slow things down. Beyond that, there isn't enough computing power available to run this everywhere it might be useful.&nbsp; The GPU shortage is the immediate manifestation of that problem.&nbsp; And should we overcome that problem, there is the question of where do we get the energy to power these computations. As things stand now, there isn't enough energy generation capacity on earth to keep up with the potential demand. I am assuming all these issues will get solved somehow.&nbsp;<br></i><br>
<div></div></div>
So, what is the future of programming? Does it even have a future?&nbsp;</div><div><br></div><div>I'm going to split the discussion this future between the short and long term. These are very different beasts.</div><div><br><div>
<h2>The Short Term: The Programmer's Apprentice is Upon Us</h2><h3>The Future of Programming, Programming Languages and Tools</h3><div>Using the AI as a tool, what happens to programming languages and IDEs?&nbsp;</div><div><br></div><div>LLMs have an intrinsic problem with accuracy. As a result, their ability to write correct programs is limited. However, they are useful in providing sketches/templates or completing boilerplate tasks. Moreover, it seems that incorporating them in a suitable enclosing architecture may help address these limitations.</div><div><br></div><div>It seems that the best applications of the technology are where text is hard to write correctly, but relatively easy to verify. Generating programs doesn't really fall into this category. It is true that programs are hard to write, but they are also hard to verify.</div><div><br></div>
<div>We need systems that are easy to verify, even if harder to write.</div><div><br></div><div><div>One approach would be to ask the system to write tests based on a specification. It is likely easier to manually ascertain the correctness of such tests than to establish the correctness of an actual program that meets the specification. Once a robust test suite is established, the system can try and write a solution and run it against the tests in order to incrementally improve.</div></div><div><br></div><div>In general, systems that are difficult for most human programmers to work with, but quite easy for machines to verify, become more attractive. Pure functional or logic programming might be beneficiaries.</div><div><br></div><div>As an example, consider the Hindley-Milner type system.&nbsp; What if an AI could clearly explain how to fix the type errors; better yet, what if it generates programs and ensures they are typesafe, by repeatedly interacting with the compiler so you don't have to? You can then read the resulting program and see if you approve, but you don't have to deal with the types.</div><div><br></div><div>Rust is yet another language where the typechecker is difficult to work with, but offers strong guarantees.</div><div><br></div></div><div>An additional step along this path might involve the use of sophisticated type systems, using, say, dependent types.<br></div><div><br></div><div>Taking this line of reasoning further, we might consider formal verification. It is very hard to prove programs correct. Checking formal specifications (which we know the program conforms to, because the theorem prover verified that) may be considerably easier.&nbsp;&nbsp;</div><div><br></div><div>Another area that might benefit is local-first software. I've long advocated for language/platform support&nbsp; for synchronization.&nbsp; The hardest problem in this area is resolving merge conflicts.&nbsp; Maybe we can have the AI look at merge conflicts and resolve them. This is worth exploring. Or, a sync transformation tool that goes over data based on metadata and writes in all the sync code may be plausible.<br></div><div><br></div><div>Overall, AI opens up new options for language design, because we have a powerful new implementation technique in the form of AI.&nbsp;</div><div><br></div><div><h3>The Future of Programs: Applications and UI</h3><div>The immediate and obvious step is the integration of AIs into applications like Office, Google Docs and so on. Conversely, we see the integration of applications into the AI interface via plugins. The latter is more significant.</div><div><br></div><div>In general, we can see that there is much less need for elaborate UIs in the traditional desktop/WIMP mode. To an extent, we revert to a command-line interface (CLI) - except that the commands are in natural language, and need not be limited to a line. This has enormous flexibility.</div><div><br></div><div>Going further, even text may become less significant as audio takes over (say, via earbuds with microphones one whispers to).</div><div><br></div><div>There are situations where a UI is still preferable. If the queries are spatial for example: it may still be easier to point, gesture or otherwise manipulate an analog control like a slider. A UI may also be useful for repeating some action.&nbsp;&nbsp;</div><div><br></div><div>However, complex hierarchies of screens and/or deeply nested menu structures seem unnecessary. In cases where a specific UI is needed, it can be generated by the AI, and customized to the user. Specialized apps will be replaced by the general chat interface, or by custom generated, simple one-off UIs.</div><div><br></div><div>We can expect the UIs that distinguish operating systems today to become less significant, and the OS' commoditized, as control of the device is increasingly done via chat.&nbsp;&nbsp;<br></div><div><br></div>
<h2>The Long Term: Programs to the People<br></h2></div>

<div><div>This is much more interesting. I expect that we reach a stage where we describe our requirements in natural language and the AI does the rest. We aren't there yet, and even if we get there, this will be a process of socratic dialogue.&nbsp; Natural language is inherently ambiguous. Either the AI asks clarifying questions, or else we get a result and play with it to see how we want it changed. So this isn't always an instant process; it still requires work, it's still programming, but in natural language.</div><div><br></div><div>Programs don't go away however. AI is a very costly way to compute, so whenever possible, we want the AI to write a classical program to do the computation.&nbsp;<br></div><div><br></div></div><div><div><div>What then, of UI? As noted above, UI still has a role to play.</div><div>I envisage a two-dimensional space with text, pictures, audio and video clips and widgets that perform tasks that are naturally visual, or simply repetitive.&nbsp; In other words, the future interface is a&nbsp;<i><b>document</b></i>&nbsp;which you can customize via natural language (spoken or written) and/or direct manipulation.<br></div></div><div><br></div></div><div><div>Ease of customization is a key point here. Natural language is the ultimate answer to the problem of end-user programming. It is the true "no-code" solution. For the first time, non-technical users of computers can have complete control over their digital environment.</div><div><br></div><div>The real significance lies in the&nbsp;<i><b>democratization of programming</b></i>.&nbsp; Now, everyone can control their digital environment, not just people with special training and a strange aptitude for thinking like a machine.<br></div><div><br></div><div>In this scenario, the AI is&nbsp;a personal assistant, separate from apps, so it can run,&nbsp;customize, program and integrate multiple apps.&nbsp; Ideally this AI is on the user's machine, but if even is a service (say, because it doesn't fit), it is the only non-local service one needs. Ideally we want a local-first AI, which can run locally, perhaps at diminished capacity.<br></div><div><br></div><div>Clearly, it isn't enough to have a fixed set of extensions, or plugins, or customization options.&nbsp; We need to be able to reprogram the system/document (via AI), so it must be open source.&nbsp;<br></div><div><br></div><div>Moreover, it is crucial that we have the document be <i><b>live</b></i>. All the arguments in favor of live programming still hold. We want to provide people with instant feedback on their changes and we want to preserve the state of the UI and the computation even when the logic of the program is modified. If anything, this is even more important now that the "programming" is done by ordinary people rather than by trained programmers.<br></div><div><br></div><div>Of course, one still wants this document to be shareable and sync'ed across multiple devices. In fact, one still wants all the properties I argued for in <a href="https://blog.bracha.org/dontSerfTheInternet.html" contenteditable="false">my previous post</a>.</div></div><div><br></div><div>Ultimately, AI can empower people by making programming a natural activity open to all. We can realize the vision of the dynabook. We must ensure however, that the programs being used are live, so that they can quickly and easily adapt to the wishes of the people who use them. Then, programming as we know it can wither away.&nbsp;</div><div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br><h3><br></h3><h3><br></h3></div><div><br></div><div><br></div><div><br><br></div></div></div></div>
</body></div>   <script type="text/javascript">
      function scheduleTurn(timeout) {
        if (timeout >= 0) {
          setTimeout(function() {
            var timeout = Module._handle_message();
            scheduleTurn(timeout);
          }, timeout);
        }
      }

      var Module = {
        noInitialRun: true,
        noExitRuntime: true,
        onRuntimeInitialized: function() {
          var url = new URLSearchParams(window.location.search);
          var request = new XMLHttpRequest();
          request.open("GET", url.get("snapshot"), true);
          request.responseType = "arraybuffer";
          request.onload = function (event) {
            var jsBuffer = new Uint8Array(request.response);
            var cBuffer = _malloc(jsBuffer.length);
            writeArrayToMemory(jsBuffer, cBuffer);
            Module._load_snapshot(cBuffer, jsBuffer.length);
            _free(cBuffer);
            scheduleTurn(0);
          };
          request.send();
        },
        print: function(text) {
          if (arguments.length > 1) {
            text = Array.prototype.slice.call(arguments).join(" ");
          }
          console.log(text);
        },
        printErr: function(text) {
          if (arguments.length > 1) {
            text = Array.prototype.slice.call(arguments).join(" ");
          }
          console.error(text);
        },
        setStatus: function(text) {
          console.log(text);
        },
      };
    </script>
<script async type="text/javascript" src="primordialsoup.js"></script>
    <script src="CodeMirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="CodeMirror/lib/codemirror.css"></link>
    <script src="CodeMirror/addon/display/autorefresh.js"></script>